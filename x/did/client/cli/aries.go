package cli

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/client/tx"
	"github.com/spf13/cobra"

	"github.com/allinbits/cosmos-cash/x/did/types"
)

// request send a json http request
func request(method, url string, requestBody io.Reader, val interface{}) (err error) {
	var client = &http.Client{
		Timeout: time.Second * 1,
	}
	req, err := http.NewRequestWithContext(context.Background(), method, url, requestBody)
	if err != nil {
		return
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(bodyBytes, &val)
	return
}

// post send a post http request
func post(url string, requestBody, val interface{}) error {
	if requestBody != nil {
		return request("POST", url, serialize(requestBody), val)
	}
	return request("POST", url, nil, val)
}

// serialize  interface to json bytes
func serialize(in interface{}) io.Reader {
	v, err := json.Marshal(in)
	if err != nil {
		// TODO: NO PANIC
		panic(err.Error())
	}
	return bytes.NewBuffer(v)
}

// keySetCreateReq struct to make a request to generate a new keySet
type keySetCreateReq struct {
	KeyType string `json:"keyType"`
}

// keySetCreateRsp response to generate a new keySet
type keySetCreateRsp struct {
	KeyID     string `json:"keyId"`
	PublicKey string `json:"publicKey"`
}

// toBytes get the public key to bytes
func (kscr keySetCreateRsp) toBytes() ([]byte, error) {
	return base64.RawURLEncoding.DecodeString(kscr.PublicKey)
}

func createKeySetOnAgent(agentURL, keyType string) (keyID string, pubKey []byte, err error) {
	var ksr keySetCreateRsp
	err = post(fmt.Sprint(agentURL, "/kms/keyset"), &keySetCreateReq{KeyType: keyType}, &ksr)
	if err != nil {
		return
	}
	pubKey, err = ksr.toBytes()
	if err != nil {
		return
	}
	keyID = ksr.KeyID
	return
}

// NewLinkAriesAgentCmd link an aries
func NewLinkAriesAgentCmd() *cobra.Command {

	var keyType string

	cmd := &cobra.Command{
		Use:     "link-aries-agent [id] [aries-agent-api-url] [service-endpoint]",
		Short:   "create a service and add a keyExchange method and relationship from an aries agent",
		Example: `cosmos-cashd tx link-aries-agent alice http://localhost:7090 http://localhost:7091`,
		Args:    cobra.ExactArgs(3),
		RunE: func(cmd *cobra.Command, args []string) error {
			clientCtx, err := client.GetClientTxContext(cmd)
			if err != nil {
				return err
			}
			signer := clientCtx.GetFromAddress()
			ariesAPIURL := args[1]
			serviceEndpoint := args[2]
			// send a http request to the aries endpoint to generate a new key
			keyID, pubKey, err := createKeySetOnAgent(ariesAPIURL, keyType)
			if err != nil {
				return err
			}
			// build the target DID
			did := types.NewChainDID(clientCtx.ChainID, args[0])
			// add a new verification method based on the key generated by aries
			vmID := did.NewVerificationMethodID(keyID)
			verification := types.NewVerification(
				types.NewVerificationMethod(
					vmID,
					did,
					types.NewPublicKeyMultibase(pubKey, types.DIDVMethodTypeX25519KeyAgreementKey2019),
				),
				[]string{types.KeyAgreement},
				nil,
			)
			// add verification message
			msgAV := types.NewMsgAddVerification(
				did.String(),
				verification,
				signer.String(),
			)

			// add service that links the aries agent that holds the private key
			service := types.NewService(
				args[0]+"-agent",
				"DIDCommMessaging",
				serviceEndpoint,
			)

			msgAS := types.NewMsgAddService(
				did.String(),
				service,
				signer.String(),
			)
			// broadcast the messages
			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msgAV, msgAS)

		},
	}

	cmd.Flags().StringVar(&keyType, "key-type", "ED25519", "the key type that the aries node should generate")
	flags.AddTxFlagsToCmd(cmd)

	return cmd
}
